import numpy as np
import matplotlib.pyplot as plt

def sigmoid(x): return 1 / (1 + np.exp(-x))
def sigmoid_deriv(x): return x * (1 - x)

X = np.array([[0,0],
              [0,1],
              [1,0],
              [1,1]])

y = np.array([[0],
              [0],
              [0],
              [1]])

np.random.seed(1)
weights = 2 * np.random.random((2,1)) - 1

bias = 0.5

errors = []   # keep track of mean error

for epoch in range(10000):
    # Forward pass
    z = np.dot(X, weights) + bias
    output = sigmoid(z)

    # Error
    error = y - output
    mean_error = np.mean(np.abs(error))
    errors.append(mean_error)   # store for plotting

    # Backprop
    adjustments = np.dot(X.T, error * sigmoid_deriv(output))
    weights += adjustments
    bias += np.sum(error * sigmoid_deriv(output))


plt.plot(errors)
plt.show() # tiny little itty bitty brain :)
